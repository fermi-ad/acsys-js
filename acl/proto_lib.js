// This is a library of routines which are common to all protocol
// message marshallers/unmarshallers. Rather than bloat each generated
// source file, the common functions are located in this file and
// shared by all generators.
//
// In the <HEAD> portion of your HTML document, add the following tag:
//
//	<script src="URI_TO_THIS_FILE"/>
//
// Generated by the Protocol Compiler.

if (!PROTOCOL) {
  function MarshalException(t, v) {
    const exceptionMessage = `'${v.toString()}' is not a type ${t}`;
    this.toString = function() {
      return exceptionMessage;
    };
    return exceptionMessage;
  }

  function tag_to_string(tag) {
    switch (tag) {
      case 0x10:
        return "integer";
      case 0x20:
        return "float";
      case 0x30:
        return "binary";
      case 0x40:
        return "string";
      case 0x50:
        return "array";
      case 0x70:
        return "boolean";
      case 0x80:
        return "enum";
      default:
        return "unknown";
    }
  }

  function UnmarshalException(t, v) {
    this.toString = function() {
      return (
        "expecting " +
        tag_to_string(t) +
        " tag but found " +
        tag_to_string(v) +
        " tag"
      );
    };
  }

  var PROTOCOL = {
    m_content: function(d, arr, n) {
      var len = n === undefined ? arr.length : n;
      var a8 = new Uint8Array(d.v.buffer, d.o, len);

      for (var ii = 0; ii < len; ++ii) a8[ii] = arr[ii];
      void (d.o += len);
    },

    m_tagged_int: function(tag, d, v) {
      if (v > 0x1fffffffffffff || v < -0x1fffffffffffff)
        throw "integer out of range";

      var b = new ArrayBuffer(8);
      var lv = new DataView(b);
      var ii = 1;

      lv.setUint32(0, Math.floor(v / 0x100000000));
      lv.setUint32(4, v);
      for (; ii < 7; ++ii) {
        var tmp = lv.getUint8(ii);

        if (
          (tmp !== 0 && tmp !== 0xff) ||
          (tmp === 0 && lv.getInt8(ii + 1) < 0)
        )
          break;
      }
      d.v.setUint8(d.o++, tag + 8 - ii);
      for (; ii < 8; ++ii) d.v.setInt8(d.o++, lv.getInt8(ii));
    },

    m_bool: function(d, v) {
      if (typeof v == "boolean" || v instanceof Boolean)
        d.v.setUint8(d.o++, v ? 0x71 : 0x70);
      else throw MarshalException("boolean", v);
    },

    m_int: function(d, v) {
      if (typeof v == "number" || v instanceof Number)
        return PROTOCOL.m_tagged_int(0x10, d, v);
      else throw MarshalException("number", v);
    },

    m_enum: function(d, v) {
      if (typeof v == "number" || v instanceof Number)
        return PROTOCOL.m_tagged_int(0x80, d, v);
      else throw MarshalException("enumeration", v);
    },

    m_float: function(d, v) {
      if (typeof v == "number" || v instanceof Number) {
        d.v.setUint8(d.o++, 0x28);
        d.v.setFloat64(d.o, v);
        void (d.o += 8);
      } else throw MarshalException("float", v);
    },

    m_string: function(d, v) {
      if (typeof v == "string" || v instanceof String) {
        var b = new Uint8Array(new ArrayBuffer(v.length * 3));
        var o = 0;

        function toUtf8(c, o) {
          if (c < 0x80) {
            b[o++] = c;
          } else if (c < 0x800) {
            b[o++] = 0xc0 + Math.floor(c / 64);
            b[o++] = 0x80 + (c % 64);
          } else if (c < 0xd800 || c > 0xdfff) {
            b[o++] = 0xe0 + Math.floor(c / 4096);
            b[o++] = 0x80 + (Math.floor(c / 64) % 64);
            b[o++] = 0x80 + (c % 64);
          } else throw "bad UTF-16 character";
          return o;
        }

        for (var ii = 0; ii < v.length; ++ii) o = toUtf8(v.charCodeAt(ii), o);

        PROTOCOL.m_tagged_int(0x40, d, o);
        PROTOCOL.m_content(d, b, o);
      } else throw MarshalException("string", v);
    },

    m_binary: function(d, v) {
      if (v instanceof ArrayBuffer) {
        var lv = new Uint8Array(v);

        PROTOCOL.m_tagged_int(0x30, d, lv.length);
        PROTOCOL.m_content(d, lv);
      } else throw MarshalException("binary", v);
    },

    m_array: function(d, a, f) {
      if (a instanceof Array) {
        PROTOCOL.m_tagged_int(0x50, d, a.length);
        for (var ii = 0; ii < a.length; ++ii) f(d, a[ii]);
      } else throw MarshalException("array", a);
    },

    m_struct: function(d, v) {
      v.marshal(d);
    },

    u_tagged_int: function(tag, d) {
      var tl = d.v.getUint8(d.o++);

      if ((tl & 0xf0) === tag) {
        var len = tl & 0xf;
        var v = d.v.getInt8(d.o++);

        if (len < 7 || (len === 7 && v >= -0x20 && v < 0x20)) {
          for (var ii = 1; ii < len; ++ii) v = v * 256 + d.v.getUint8(d.o++);
          return v;
        } else throw "incoming integer too large";
      } else throw UnmarshalException(tag, tl & 0xf0);
    },

    u_int: function(d) {
      return PROTOCOL.u_tagged_int(0x10, d);
    },

    u_float: function(d) {
      var tl = d.v.getUint8(d.o++);

      if (tl === 0x28) {
        var tmp = d.v.getFloat64(d.o);

        d.o += 8;
        return tmp;
      } else UnmarshalException(0x28, tl & 0xf0);
    },

    u_bool: function(d) {
      switch (d.v.getUint8(d.o++)) {
        case 0x70:
          return false;
        case 0x71:
          return true;
        default:
          throw UnmarshalException(0x70, 0);
      }
    },

    u_string: function(d) {
      var len = PROTOCOL.u_tagged_int(0x40, d);
      var v = new String("");

      function toUtf16(d) {
        var c1 = d.v.getUint8(d.o++);

        if ((0x80 & c1) === 0) {
          v += String.fromCharCode(c1);
          return 1;
        } else if ((0xe0 & c1) === 0xc0) {
          var c2 = d.v.getUint8(d.o++);

          if ((0xc0 & c2) === 0x80) {
            v += String.fromCharCode((c1 % 32 << 6) + (c2 % 64));
            return 2;
          }
        } else if ((0xf0 & c1) === 0xe0) {
          var c2 = d.v.getUint8(d.o++);
          var c3 = d.v.getUint8(d.o++);

          if ((0xc0 & c2) === 0x80 && (0xc0 & c3) === 0x80) {
            v += String.fromCharCode(
              (c1 % 16 << 12) + (c2 % 64 << 6) + (c3 % 64)
            );
            return 3;
          }
        }
        throw "bad UTF-8 character";
      }

      for (var ii = 0; ii < len; ii += toUtf16(d));
      return v;
    },

    u_binary: function(d) {
      var len = PROTOCOL.u_tagged_int(0x30, d);
      var off = d.v.byteOffset + d.o;

      d.o += len;
      return d.v.buffer.slice(off, off + len);
    },

    u_array: function(d, f) {
      var n = PROTOCOL.u_tagged_int(0x50, d);
      var a = [];

      for (var ii = 0; ii < n; ++ii) a.push(f(d));
      return a;
    }
  };

  Object.freeze(PROTOCOL);
}

// Local Variables:
// tab-width:4
// mode:javascript
// End:
