// This is a library of routines which are common to all protocol
// message marshallers/unmarshallers. Rather than bloat each generated
// source file, the common functions are located in this file and
// shared by all generators.
//
// In the <HEAD> portion of your HTML document, add the following tag:
//
//	<script src="URI_TO_THIS_FILE"/>
//
// Generated by the Protocol Compiler.

// Define a class that report marshaling errors.

export class MarshalError extends Error {
    constructor(t, v) {
	super(`'${v}' is not of type ${t}`);
    }
}

// Define a class that reports unmarshaling errors.

export class UnmarshalError extends Error {
    constructor (t1, t2) {
	function tag_to_string(tag) {
	    switch (tag) {
	    case 0x10:	return "integer";
	    case 0x20:	return "float";
	    case 0x30:	return "binary";
	    case 0x40:	return "string";
	    case 0x50:	return "array";
	    case 0x70:	return "boolean";
	    case 0x80:	return "enum";
	    default:	return "unknown";
	    }
	}

	super(`expecting ${tag_to_string(t1)} tag but found ${tag_to_string(t2)} tag`);
    }
}

export class PROTOCOL {
    static *m_tagged_int(tag, v) {
	if (!Number.isSafeInteger(v))
	    throw new RangeError("Integer cannot be represented.");

	// Create a location to hold the bytes of the 64-bit integer.
	// Create a DataView so we can re-interpret the type of the
	// buffer.

	const b = new ArrayBuffer(8);
	const lv = new DataView(b);
        const result = new Uint8Array(b);

	// Store the two halves of the 64-bit integer.

	lv.setUint32(0, Math.floor(v / 0x100000000));
	lv.setUint32(4, v);

        const ii = v >= 0 ?
              (v < 0x80 ? 7 :
               (v < 0x8000 ? 6 :
                (v < 0x800000 ? 5 :
                 (v < 0x80000000 ? 4 :
                  (v < 0x8000000000 ? 3 :
                   (v < 0x800000000000 ? 2 :
                    (v < 0x80000000000000 ? 1 : 0))))))) :
              (v >= -0x80 ? 7 :
               (v >= -0x8000 ? 6 :
                (v >= -0x800000 ? 5 :
                 (v >= -0x80000000 ? 4 :
                  (v >= -0x8000000000 ? 3 :
                   (v >= -0x800000000000 ? 2 :
                    (v >= -0x80000000000000 ? 1 : 0)))))));

	yield (tag & 0xf0) | (8 - ii);
        yield* result.subarray(ii);
    }

    static *m_bool(v) {
	if (typeof(v) == "boolean" || v instanceof Boolean)
	    yield (v ? 0x71 : 0x70);
	else
	    throw new MarshalError("boolean", v);
    }

    static *m_int(v) {
	if (typeof(v) == "number" || v instanceof Number)
	    yield* PROTOCOL.m_tagged_int(0x10, v);
	else
	    throw new MarshalError("number", v);
    }

    static *m_enum(v) {
	if (typeof(v) == "number" || v instanceof Number)
	    yield* PROTOCOL.m_tagged_int(0x80, v);
	else
	    throw new MarshalError("enumeration", v);
    }

    static *m_float(v) {
	if (typeof(v) == "number" || v instanceof Number) {
	    const b = new ArrayBuffer(9);
	    const lv = new DataView(b);
            const result = new Uint8Array(b);

	    // Write the tag and store the bytes of the value.

	    lv.setUint8(0, 0x28);
	    lv.setFloat64(1, v);

	    // Re-interpret the array as contaning unsigned, 8-bit
	    // values and return a generator that iterates through it.

	    yield* result;
	} else
	    throw new MarshalError("float", v);
    }

    static *m_string(v) {
	if (typeof(v) == "string" || v instanceof String) {
	    function* yieldUtf8(c) {
                const code = c.charCodeAt(0);

		if (c < '\u0080')
		    yield code;
		else {
		    if (c < '\u0800')
			yield 0xc0 + (code >> 6);
		    else if (c < '\ud800' || c > '\udfff') {
			yield 0xe0 + (code >> 12);
			yield 0x80 + ((code >> 6) & 0x3f);
		    } else
			throw new RangeError("Bad UTF-16 character.");
		    yield 0x80 | (code & 0x3f);
		}
	    }

	    // Determine the length of the final, UTF-8 string by
	    // summing the sizes required by each UTF-16
	    // character.

	    var len = 0;

	    for (let code of v)
		len += (code < '\u0080' ? 1 : (code < '\u0800' ? 2 : 3));

	    // Emit the tag/length byte and then the contents of
	    // the string (converting it to UTF-8, as it iterates
	    // through.)

	    yield* PROTOCOL.m_tagged_int(0x40, len);
	    for (let ii of v)
		yield* yieldUtf8(ii);
	} else
	    throw new MarshalError("string", v);
    }

    static *m_binary(v) {
	if (v instanceof ArrayBuffer) {
	    yield* PROTOCOL.m_tagged_int(0x30, v.byteLength);
	    yield* new Uint8Array(v);
	} else
	    throw new MarshalError("binary", v);
    }

    static *m_array(f, a) {
	if (a instanceof Array) {
	    yield* PROTOCOL.m_tagged_int(0x50, a.length);
	    for (let ii of a)
		yield* f(ii);
	} else
	    throw new MarshalError("array", a);
    }

    static *m_struct(v) { yield* v.marshal(); }

    static get_next(i) {
        const tmp = i.next();

        if (tmp.done && tmp.value === undefined)
            throw new Error("Unexpected end of input.");
        return tmp.value;
    }

    static validate_header(v, i) {
	if (PROTOCOL.get_next(i) === 83 && PROTOCOL.get_next(i) === 68 &&
	    PROTOCOL.get_next(i) === 68 && PROTOCOL.get_next(i) === v)
	    return;
	throw new Error("Packet has invalid header.");
    }

    static u_tagged_int(tag, g) {
	const tl = PROTOCOL.get_next(g);

	if ((tl & 0xf0) === tag) {
	    const len = tl & 0xf;
	    var v = PROTOCOL.get_next(g);

	    // We read each byte as an unsigned, 8-bit value. If
	    // the first byte of the integer is 0x80, or greater,
	    // then the integer is negative. Subtracting 256 from
	    // it sets the first byte to the proper, negative
	    // value.

	    if (v >= 0x80)
		v -= 256;

	    // If the integer isn't going to exceed what
	    // Javascript is able to represent, loop through the
	    // rest of its data and build up the value to return.

	    if (len < 7 || (len === 7 && v >= -0x20 && v < 0x20)) {
		for (var ii = 1; ii < len; ++ii)
		    v = (v * 256) + PROTOCOL.get_next(g);
		return v;
	    } else
		throw new RangeError("Incoming integer too large.");
	} else
	    throw new UnmarshalError(tag, tl & 0xf0);
    }

    static u_int(g) { return PROTOCOL.u_tagged_int(0x10, g); }

    static u_float(g) {
	const tl = PROTOCOL.get_next(g);

	if (tl === 0x28) {
	    const b = new ArrayBuffer(8);
            const dv = new DataView(b);

	    for (let idx = 0; idx < 8; ++idx)
                dv.setUint8(idx, PROTOCOL.get_next(g));

	    return dv.getFloat64(0);
	} else
	    throw new UnmarshalError(0x28, tl & 0xf0)
    }

    static u_bool(g) {
	const tl = PROTOCOL.get_next(g);

	switch (tl) {
	case 0x70:	return false;
	case 0x71:	return true;
	default:	throw new UnmarshalError(0x70, tl & 0xf0);
	}
    }

    static u_string(g) {
	const len = PROTOCOL.u_tagged_int(0x40, g);
	var v = new String("");

	function toUtf16() {
	    const c1 = PROTOCOL.get_next(g);

	    if ((0x80 & c1) === 0) {
		v += String.fromCharCode(c1);
		return 1;
	    } else {
		if ((0xe0 & c1) === 0xc0) {
		    const c2 = PROTOCOL.get_next(g);

		    if ((0xc0 & c2) === 0x80) {
			v += String.fromCharCode(((c1 % 32) << 6) |
						 (c2 % 64));
			return 2;
		    }
		} else if ((0xf0 & c1) === 0xe0) {
		    const c2 = PROTOCOL.get_next(g);
		    const c3 = PROTOCOL.get_next(g);

		    if ((0xc0 & c2) === 0x80 && (0xc0 & c3) === 0x80) {
			v += String.fromCharCode(((c1 % 16) << 12) |
						 ((c2 % 64) << 6) |
						 (c3 % 64));
			return 3;
		    }
		}
	    }
	    throw new RangeError("Bad UTF-8 character.");
	}

	for (let ii = 0; ii < len; ii += toUtf16())
	    ;
	return v;
    }

    static u_binary(g) {
	const n = PROTOCOL.u_tagged_int(0x30, g);
	const buf = new Uint8Array(n);

	for (let ii = 0; ii < n; ++ii)
	    buf[ii] = PROTOCOL.get_next(g);

	return buf.buffer;
    }

    static u_array(f, g) {
	const n = PROTOCOL.u_tagged_int(0x50, g);
	const a = [];

	for (let ii = 0; ii < n; ++ii)
	    a.push(f(g));
	return a;
    }
};
