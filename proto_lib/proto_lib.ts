// This is a library of routines which are common to all protocol
// message marshallers/unmarshallers. Rather than bloat each generated
// source file, the common functions are located in this file and
// shared by all generators.
//
// In the <HEAD> portion of your HTML document, add the following tag:
//
//	<script src="URI_TO_THIS_FILE"/>
//
// Generated by the Protocol Compiler.

// Define a class that report marshaling errors.

export class MarshalError extends Error {
    constructor(t: string, v: string) {
	super(`'${v}' is not of type ${t}`);
    }
}

// Define a class that reports unmarshaling errors.

export class UnmarshalError extends Error {
    constructor (t1: number, t2: number) {
	function tag_to_string(tag: number): string {
	    switch (tag) {
	    case 0x10:	return "integer";
	    case 0x20:	return "float";
	    case 0x30:	return "binary";
	    case 0x40:	return "string";
	    case 0x50:	return "array";
	    case 0x70:	return "boolean";
	    case 0x80:	return "enum";
	    default:	return "unknown";
	    }
	}

	super(`expecting ${tag_to_string(t1)} tag but found ${tag_to_string(t2)} tag`);
    }
}

interface Marshalable {
    marshal(): IterableIterator<number>;
}

export class PROTOCOL {
    static *m_tagged_int(tag: number, v: number): IterableIterator<number> {
	if (!Number.isSafeInteger(v))
	    throw new RangeError("Integer cannot be represented.");

	// Create a location to hold the bytes of the 64-bit integer.
	// Create a DataView so we can re-interpret the type of the
	// buffer.

	const b = new ArrayBuffer(8);
	const lv = new DataView(b);
        const result = new Uint8Array(b);

	// Store the two halves of the 64-bit integer.

	lv.setUint32(0, Math.floor(v / 0x100000000));
	lv.setUint32(4, v);

        const ii = v >= 0 ?
              (v < 0x80 ? 7 :
               (v < 0x8000 ? 6 :
                (v < 0x800000 ? 5 :
                 (v < 0x80000000 ? 4 :
                  (v < 0x8000000000 ? 3 :
                   (v < 0x800000000000 ? 2 :
                    (v < 0x80000000000000 ? 1 : 0))))))) :
              (v >= -0x80 ? 7 :
               (v >= -0x8000 ? 6 :
                (v >= -0x800000 ? 5 :
                 (v >= -0x80000000 ? 4 :
                  (v >= -0x8000000000 ? 3 :
                   (v >= -0x800000000000 ? 2 :
                    (v >= -0x80000000000000 ? 1 : 0)))))));

	yield (tag & 0xf0) | (8 - ii);
        yield* result.subarray(ii);
    }

    static *m_bool(v: boolean): IterableIterator<number> {
	yield (v ? 0x71 : 0x70);
    }

    static *m_int(v: number): IterableIterator<number> {
	yield* PROTOCOL.m_tagged_int(0x10, v);
    }

    static *m_enum(v: number): IterableIterator<number> {
	yield* PROTOCOL.m_tagged_int(0x80, v);
    }

    static *m_float(v: number): IterableIterator<number> {
	const b = new ArrayBuffer(9);
	const lv = new DataView(b);
        const result = new Uint8Array(b);

	// Write the tag and store the bytes of the value.

	lv.setUint8(0, 0x28);
	lv.setFloat64(1, v);

	// Re-interpret the array as contaning unsigned, 8-bit values
	// and return a generator that iterates through it.

	yield* result;
    }

    static *m_string(v: string): IterableIterator<number> {
	function* yieldUtf8(c: string): IterableIterator<number> {
            const code = c.charCodeAt(0);

	    if (c < '\u0080')
		yield code;
	    else {
		if (c < '\u0800')
		    yield 0xc0 + (code >> 6);
		else if (c < '\ud800' || c > '\udfff') {
		    yield 0xe0 + (code >> 12);
		    yield 0x80 + ((code >> 6) & 0x3f);
		} else
		    throw new RangeError("Bad UTF-16 character.");
		yield 0x80 | (code & 0x3f);
	    }
	}

	// Determine the length of the final, UTF-8 string by summing
	// the sizes required by each UTF-16 character.

	let len = 0;

	for (let code of v)
	    len += (code < '\u0080' ? 1 : (code < '\u0800' ? 2 : 3));

	// Emit the tag/length byte and then the contents of the
	// string (converting it to UTF-8, as it iterates through.)

	yield* PROTOCOL.m_tagged_int(0x40, len);
	for (let ii of v)
	    yield* yieldUtf8(ii);
    }

    static *m_binary(v: ArrayBuffer): IterableIterator<number> {
	yield* PROTOCOL.m_tagged_int(0x30, v.byteLength);
	yield* new Uint8Array(v);
    }

    static *m_array<T>(f: (v: T) => IterableIterator<number>, a: Array<T>): IterableIterator<number> {
	yield* PROTOCOL.m_tagged_int(0x50, a.length);
	for (let ii of a)
	    yield* f(ii);
    }

    static *m_struct(v: Marshalable): IterableIterator<number> { yield* v.marshal(); }

    static get_next(i: Iterator<number>): number {
        const { done, value } = i.next();

        if (done && value === undefined)
            throw new Error("Unexpected end of input.");
        return value;
    }

    static validate_header(v: number, i: Iterator<number>): void {
	if (PROTOCOL.get_next(i) === 83 && PROTOCOL.get_next(i) === 68 &&
	    PROTOCOL.get_next(i) === 68 && PROTOCOL.get_next(i) === v)
	    return;
	throw new Error("Packet has invalid header.");
    }

    static u_tagged_int(tag: number, g: Iterator<number>): number {
	const tl = PROTOCOL.get_next(g);

	if ((tl & 0xf0) === tag) {
	    const len = tl & 0xf;
	    let v = PROTOCOL.get_next(g);

	    // We read each byte as an unsigned, 8-bit value. If
	    // the first byte of the integer is 0x80, or greater,
	    // then the integer is negative. Subtracting 256 from
	    // it sets the first byte to the proper, negative
	    // value.

	    if (v >= 0x80)
		v -= 256;

	    // If the integer isn't going to exceed what
	    // Javascript is able to represent, loop through the
	    // rest of its data and build up the value to return.

	    if (len < 7 || (len === 7 && v >= -0x20 && v < 0x20)) {
		for (let ii = 1; ii < len; ++ii)
		    v = (v * 256) + PROTOCOL.get_next(g);
		return v;
	    } else
		throw new RangeError("Incoming integer too large.");
	} else
	    throw new UnmarshalError(tag, tl & 0xf0);
    }

    static u_int(g: Iterator<number>): number { return PROTOCOL.u_tagged_int(0x10, g); }

    static u_float(g: Iterator<number>): number {
	const tl = PROTOCOL.get_next(g);

	if (tl === 0x28) {
	    const b = new ArrayBuffer(8);
            const dv = new DataView(b);

	    for (let idx = 0; idx < 8; ++idx)
                dv.setUint8(idx, PROTOCOL.get_next(g));

	    return dv.getFloat64(0);
	} else
	    throw new UnmarshalError(0x28, tl & 0xf0)
    }

    static u_bool(g: Iterator<number>): boolean {
	const tl = PROTOCOL.get_next(g);

	switch (tl) {
	case 0x70:	return false;
	case 0x71:	return true;
	default:	throw new UnmarshalError(0x70, tl & 0xf0);
	}
    }

    static u_string(g: Iterator<number>): string {
	const len = PROTOCOL.u_tagged_int(0x40, g);
	let v = "";

	function toUtf16(): number {
	    const c1 = PROTOCOL.get_next(g);

	    if ((0x80 & c1) === 0) {
		v += String.fromCharCode(c1);
		return 1;
	    } else {
		if ((0xe0 & c1) === 0xc0) {
		    const c2 = PROTOCOL.get_next(g);

		    if ((0xc0 & c2) === 0x80) {
			v += String.fromCharCode(((c1 % 32) << 6) |
						 (c2 % 64));
			return 2;
		    }
		} else if ((0xf0 & c1) === 0xe0) {
		    const c2 = PROTOCOL.get_next(g);
		    const c3 = PROTOCOL.get_next(g);

		    if ((0xc0 & c2) === 0x80 && (0xc0 & c3) === 0x80) {
			v += String.fromCharCode(((c1 % 16) << 12) |
						 ((c2 % 64) << 6) |
						 (c3 % 64));
			return 3;
		    }
		}
	    }
	    throw new RangeError("Bad UTF-8 character.");
	}

	for (let ii = 0; ii < len; ii += toUtf16())
	    ;
	return v;
    }

    static u_binary(g: Iterator<number>): ArrayBuffer {
	const n = PROTOCOL.u_tagged_int(0x30, g);
	const buf = new Uint8Array(n);

	for (let ii = 0; ii < n; ++ii)
	    buf[ii] = PROTOCOL.get_next(g);

	return buf.buffer;
    }

    static u_array<T>(f: (iter: Iterator<number>) => T, g: Iterator<number>): Array<T> {
	const n = PROTOCOL.u_tagged_int(0x50, g);
	const a = [];

	for (let ii = 0; ii < n; ++ii)
	    a.push(f(g));
	return a;
    }
};
